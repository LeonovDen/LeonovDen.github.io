---
layout: page
title: Требования к системам
---
<section>
	<div id="availability">
		<hr />
		<h3>Доступность</h3>
		<hr />
		<p>Доступность — это время, в течение которого система остается работоспособной для выполнения требуемой
			функции в течение определенного периода времени. Это простая мера процента времени, в течение которого
			система, служба или машина остаются работоспособными в нормальных условиях.
		<div>
			<h4>Девятка доступности</h4>
			<p>Доступность часто измеряется временем безотказной работы (или временем простоя) в процентах от времени,
				в течение которого служба доступна. Обычно измеряется числом девяток.
		<p><img src="../images/availability.svg" width="35%" height="15.6%"></p>
			<p>Если доступность составляет 99,00%, говорят, что она имеет «2 девятки» доступности, а если она составляет
				99,9%, она называется «3 девятки» и так далее.
		<table>
			<thead>
			<tr>
				<th>Доступность (%)</th>
				<th>Время простоя (год)</th>
				<th>Время простоя (месяц)</th>
				<th>Время простоя (неделя)</th>
			</tr>
			</thead>
			<tbody>
			<tr>
				<td>90% (одна девятка)</td>
				<td>36.53 дней</td>
				<td>72 часов</td>
				<td>16.8 часов</td>
			</tr>
			<tr>
				<td>99% (две девятки)</td>
				<td>3.65 дней</td>
				<td>7.20 часов</td>
				<td>1.68 часов</td>
			</tr>
			<tr>
				<td>99.9% (три девятки)</td>
				<td>8.77 часов</td>
				<td>43.8 минут</td>
				<td>10.1 минут</td>
			</tr>
			<tr>
				<td>99.99% (четыре девятки)</td>
				<td>52.6 минут</td>
				<td>4.32 минут</td>
				<td>1.01 минут</td>
			</tr>
			<tr>
				<td>99.999% (пять девяток)</td>
				<td>5.25 минут</td>
				<td>25.9 минут</td>
				<td>6.05 минут</td>
			</tr>
			<tr>
				<td>99.9999% (шесть девяток)</td>
				<td>31.56 минут</td>
				<td>2.59 минут</td>
				<td>604.8 миллисекунд</td>
			</tr>
			</tbody>
		</table>
	</div>
		<div>
			<h4>Доступность в последовательном и параллельном режимах</h4>
			<p>Если служба состоит из нескольких компонентов, подверженных сбоям, общая доступность службы зависит от
				того, расположены ли компоненты последовательно или параллельно.
			<p>Общая доступность снижается, когда два компонента расположены последовательно.
			<p>Например, если и Foo, и Bar имеют доступность 99,9 %, их общая доступность по очереди будет составлять
			99,8 %.
			<p>Общая доступность увеличивается, когда два компонента работают параллельно.
			<p>Например, если и Foo, и Bar имеют доступность 99,9 %, их общая доступность при параллельном
			использовании составит 99,9999 %.
		</div>
		<div>
			<h4>Доступность против надежности</h4>
			<p>Если система надежна, она доступна. Однако, если он доступен, он не обязательно надежен. Другими словами,
				высокая надежность способствует высокой доступности, но добиться высокой доступности можно даже в
				ненадежной системе.
		</div>
		<div>
			<h4>Высокая доступность и отказоустойчивость</h4>
			<p>И высокая доступность, и отказоустойчивость применимы к методам обеспечения высокого уровня безотказной
				работы. Однако они достигают поставленной цели по-разному.
			<p>Отказоустойчивая система не имеет перерывов в обслуживании, но значительно дороже, в то время как
			высокодоступная система имеет минимальное прерывание обслуживания. Отказоустойчивость требует полного
			аппаратного резервирования, поскольку в случае сбоя основной системы без потери времени безотказной работы
			ее должна взять на себя другая система.
		</div>
	</div>
	<div id="scalability">
		<hr />
		<h3>Масштабируемость</h3>
		<hr />
		<p>Масштабируемость — это мера того, насколько хорошо система реагирует на изменения, добавляя или удаляя
			ресурсы для удовлетворения потребностей.
		<p>Давайте обсудим различные типы масштабирования:
		<div>
			<h4>Вертикальное масштабирование</h4>
			<p>Вертикальное масштабирование (также известное как масштабирование вверх) расширяет масштабируемость
				системы за счет увеличения мощности существующей машины. Другими словами, вертикальное масштабирование
				означает улучшение возможностей приложения за счет увеличения мощности оборудования.
			<p>Преимущества:
			<ul>
				<li>Простота реализации</li>
				<li>Легче управлять</li>
				<li>Согласованность данных</li>
			</ul>
			<p>Недостатки:
			<ul>
				<li>Риск длительного простоя</li>
				<li>Сложнее обновить</li>
				<li>Может быть единой точкой отказа</li>
			</ul></p>
		</div>
		<div>
			<h4>Горизонтальное масштабирование</h4>
			<p>Горизонтальное масштабирование (также известное как горизонтальное масштабирование) расширяет масштаб
				системы за счет добавления дополнительных машин. Это повышает производительность сервера за счет
				добавления дополнительных экземпляров в существующий пул серверов, что позволяет более равномерно
				распределять нагрузку.
			<p>Преимущества:
			<ul>
				<li>Повышенная избыточность</li>
				<li>Лучшая отказоустойчивость</li>
				<li>Гибкость и эффективность</li>
				<li>Легче обновить</li>
			</ul>
			<p>Недостатки:
			<ul>
				<li>Повышенная сложность</li>
				<li>Несоответствие данных</li>
				<li>Повышенная нагрузка на нижестоящие сервисы</li>
			</ul>
		</div>
	</div>
	<div id="sla&slo&sli">
		<h3>SLA, SLO, SLI</h3>
		<p>Кратко обсудим SLA, SLO и SLI. В основном они связаны с бизнесом и надежностью сайта, но, тем не менее, это полезно знать.</p>
		<div>
			<h4>Почему они важны?</h4>
			<p>SLA, SLO и SLI позволяют компаниям определять, отслеживать и отслеживать обещания, данные пользователям в отношении услуги. Вместе SLA, SLO и SLI должны помочь командам повысить доверие пользователей к их услугам с дополнительным акцентом на постоянное совершенствование процессов управления инцидентами и реагирования.</p>
		</div>
		<div>
			<h4>Соглашение об уровне обслуживания</h4>
			<p>SLA или Соглашение об уровне обслуживания — это соглашение, заключенное между компанией и ее пользователями данной услуги. SLA определяет различные обещания, которые компания дает пользователям в отношении конкретных показателей, таких как доступность службы.</p>
			<p><em>SLA часто составляются бизнес- или юридическим отделом компании.</em></p>
		</div>
		<div>
			<h4>SLO</h4>
			<p>SLO, или цель уровня обслуживания, — это обещание, которое компания дает пользователям в отношении определенной метрики, такой как реакция на инцидент или время безотказной работы. SLO существуют в SLA как отдельные обещания, содержащиеся в полном пользовательском соглашении. SLO — это конкретная цель, которой должна соответствовать служба, чтобы соответствовать SLA. SLO всегда должны быть простыми, четко определенными и легко измеряемыми, чтобы определить, выполняется ли цель.</p>
		</div>
		<div>
			<h4>SLI</h4>
			<p>SLI, или индикатор уровня обслуживания, является ключевой метрикой, используемой для определения того, соблюдается ли SLO. Это измеренное значение метрики, описанной в SLO. Чтобы оставаться в соответствии с SLA, значение SLI всегда должно соответствовать или превышать значение, определенное SLO.</p>
		</div>
	</div>
	<div id="ttl">
		<h3>TTL</h3>
	</div>
	<div id="cashing">
		<hr />
		<h3>Кэширование</h3>
		<hr />
		<p>«В компьютерных науках есть только две сложные вещи: инвалидация кэша и присвоение имен вещам». -
			<a href="https://www.karlton.org/2017/12/naming-things-hard/">Фил Карлтон</a>
		<p>Основная цель кэша — повысить производительность извлечения данных за счет уменьшения необходимости доступа
			к нижележащему более медленному слою хранения. В обмен на емкость в обмен на скорость кэш обычно временно
			хранит подмножество данных, в отличие от баз данных, данные которых обычно полны и долговечны.
		<p>Кэш использует принцип локальности ссылки «недавно запрошенные данные, вероятно, будут запрошены снова».
		<div>
			<h4>Кэширование и память</h4>
			<p>Как и память компьютера, кэш — это компактная, быстродействующая память, в которой данные хранятся в
				виде иерархии уровней, начиная с первого уровня и последовательно продвигаясь оттуда. Они обозначаются
				как L1, L2, L3 и так далее. Кэш также записывается по запросу, например, когда произошло обновление, и
				новый контент необходимо сохранить в кэше, заменив старый сохраненный контент.
			<p>Независимо от того, читается ли кеш или записывается, это делается по одному блоку за раз. У каждого
				блока также есть тег, который включает место, где данные были сохранены в кэше. Когда данные
				запрашиваются из кэша, выполняется поиск по тегам, чтобы найти конкретное содержимое, необходимое на
				первом уровне (L1) памяти. Если правильные данные не найдены, в L2 выполняется дополнительный поиск.
			<p>Если данные там не найдены, поиск продолжается в L3, затем в L4 и так далее, пока они не будут найдены,
				затем они считываются и загружаются. Если данные вообще не найдены в кеше, то они записываются в него
				для быстрого извлечения в следующий раз.
		</div>
		<div>
			<h4>Попадание в кеш и промах кеша</h4>
			<div>
				<h5>Попадание в кэш</h5>
				<p>Попадание в кеш описывает ситуацию, когда содержимое успешно обслуживается из кеша. Теги быстро
					ищутся в памяти, и когда данные найдены и прочитаны, это считается попаданием в кеш.
				<p>Холодный, теплый и горячий кэш
				<p>Попадание в кэш также может быть описано как холодное, теплое или горячее. В каждом из них
					описывается скорость, с которой считываются данные.
				<p>Горячий кэш — это экземпляр, в котором данные считывались из памяти с максимально возможной
					скоростью. Это происходит, когда данные извлекаются из L1.
				<p>Холодный кеш — это самая медленная возможная скорость чтения данных, однако он по-прежнему успешен,
					поэтому он по-прежнему считается попаданием в кеш. Данные просто находятся ниже в иерархии памяти,
					например, в L3 или ниже.
				<p>Теплый кэш используется для описания данных, находящихся в L2 или L3. Это не так быстро, как горячий
					кеш, но все же быстрее, чем холодный кеш. Как правило, кеш называют теплым, чтобы показать, что он
					медленнее и ближе к холодному кешу, чем к горячему.
			</div>
			<div>
				<h5>Промах кеша</h5>
				<p>Кэш-промах относится к случаю, когда в памяти выполняется поиск, а данные не найдены. Когда это
					происходит, содержимое передается и записывается в кэш.
			</div>
		</div>
		<div>
			<h4>Инвалидация кеша</h4>
			<p>Аннулирование кэша — это процесс, при котором компьютерная система объявляет записи кэша
				недействительными и удаляет или заменяет их. Если данные изменены, они должны быть признаны
				недействительными в кэше, иначе это может привести к непоследовательному поведению приложения.
				Существует три типа систем кэширования:
			<ul>
				<li><b>Кэш со сквозной записью</b> - Данные записываются в кэш и соответствующую базу данных одновременно.
					<p>Плюсы: быстрый поиск, полная согласованность данных между кешем и хранилищем.<br>Минусы: более
						высокая задержка для операций записи.</li>
				<li><b>Кэш с круговой записью</b> - Где запись напрямую идет в базу данных или постоянное хранилище,
					минуя кеш.
					<p>Плюсы: это может уменьшить задержку.<br> Минусы: это увеличивает промахи кеша, потому что
						система кеша должна считывать информацию из базы данных в случае промаха кеша. В результате это
						может привести к более высокой задержке чтения в случае приложений, которые быстро записывают и
						повторно считывают информацию. Чтение происходит из более медленного внутреннего хранилища и
						имеет большую задержку.</li>
				<li><b>Кэш обратной записи</b> - Где запись выполняется только на уровне кэширования, и запись
					подтверждается, как только запись в кэш завершается. Затем кеш асинхронно синхронизирует эту запись
					с базой данных.
					<p>Плюсы: это приведет к уменьшению задержки и высокой пропускной способности для приложений с
						интенсивным записью. <br> Минусы: существует риск потери данных в случае сбоя кэширующего слоя.
						Мы можем улучшить это, имея более одной реплики, подтверждающей запись в кэш.</li>
			</ul>
		</div>
		<div>
			<h4>Политика выселения</h4>
			<p>Ниже приведены некоторые из наиболее распространенных политик вытеснения кэша:
			<ul>
				<li><strong>First In First Out (FIFO)</strong>: Кэш удаляет первый блок, к которому был получен доступ
					первым, независимо от того, как часто или сколько раз к нему обращались раньше.</li>
				<li><strong>Last In First Out (LIFO)</strong>: Кэш сначала удаляет блок, к которому был получен
					последний доступ, независимо от того, как часто или сколько раз к нему обращались ранее.</li>
				<li><strong>Наименее недавно использовавшиеся (LRU)</strong>: в первую очередь отбрасываются наименее
					использовавшиеся элементы.</li>
				<li><strong>Самые последние использованные (MRU)</strong>: в отличие от LRU, в первую очередь
					отбрасываются самые последние использованные элементы.</li>
				<li><strong>Наименее часто используемый (LFU)</strong>: подсчитывает, как часто требуется элемент.
					В первую очередь отбрасываются те, которые используются реже всего</li>
				<li><strong>Случайная замена (RR)</strong>: случайным образом выбирает элемент-кандидат и отбрасывает
					его, чтобы освободить место, когда это необходимо.</li>
			</ul>
		</div>
		<div>
			<h4>Распределенный кэш</h4>
			<p>Распределенный кэш — это система, которая объединяет оперативную память (ОЗУ) нескольких сетевых
				компьютеров в единое хранилище данных в памяти, используемое в качестве кэша данных для обеспечения
				быстрого доступа к данным. В то время как большинство кэшей традиционно находится на одном физическом
				сервере или аппаратном компоненте, распределенный кэш может выйти за пределы памяти одного компьютера,
				связав вместе несколько компьютеров.
		</div>
		<div>
			<h4>Глобальный кэш</h4>
			<p>Как следует из названия, у нас будет один общий кеш, который будут использовать все узлы приложения.
				Когда запрошенные данные не найдены в глобальном кэше, кэш отвечает за обнаружение отсутствующей части
				данных в базовом хранилище данных.
		</div>
		<div>
			<h4>Случаи использования и преимущества кэширования</h4>
			<p>Кэширование может иметь много реальных вариантов использования, таких как:
			<ul>
				<li>Кэширование базы данных</li>
				<li>Сеть доставки контента (CDN)</li>
				<li>Кэширование системы доменных имен (DNS)</li>
				<li>Кэширование API</li>
			</ul>
			<p>Давайте также рассмотрим некоторые сценарии, в которых нам не следует использовать кеш:
			<ul>
				<li>Кэширование бесполезно, когда доступ к кешу занимает столько же времени, сколько и доступ к
					первичному хранилищу данных.</li>
				<li>Кэширование также не работает, когда запросы имеют мало повторений (более высокая случайность),
					потому что производительность кэширования зависит от повторяющихся шаблонов доступа к памяти.</li>
				<li>Кэширование бесполезно, когда данные часто изменяются, так как кэшированная версия не
					синхронизируется, и каждый раз необходимо обращаться к первичному хранилищу данных.</li>
				<li>Важно отметить, что кеш не следует использовать в качестве постоянного хранилища данных. Они почти
					всегда реализуются в энергозависимой памяти, потому что она быстрее и, следовательно, должна
					считаться временной.</li>
			</ul>
			<p>Ниже приведены некоторые преимущества кэширования:
			<ul>
				<li>Улучшает производительность</li>
				<li>Уменьшить задержку</li>
				<li>Снизить нагрузку на базу данных</li>
				<li>Снизить стоимость сети</li>
				<li>Увеличение скорости чтения</li>
			</ul>
		</div>
		<div>
			<h4>Примеры</h4>
			<p>Вот некоторые часто используемые технологии кэширования:
			<ul>
				<li>Редис</li>
				<li>Memcached</li>
				<li>Амазонка Эластичная боль</li>
				<li>Аэроспайк</li>
			</ul>
		</div>
	</div>
</section>


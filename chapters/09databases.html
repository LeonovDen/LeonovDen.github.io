---
layout: page
title: Базы данных
---
<section>
	<div>
		<h3>О базах данных, их видах и компонентах</h3>
		<hr />
		<div>
			<h4>Что такое база данных?</h4>
			<p>База данных представляет собой организованный набор структурированной информации или данных, обычно
				хранящихся в электронном виде в компьютерной системе. База данных обычно управляется системой
				управления базами данных (СУБД). Вместе данные и СУБД вместе со связанными с ними приложениями
				называются системой баз данных, часто сокращенной до просто базы данных.</p>
		</div>
		<div>
			<h4>Что такое СУБД?</h4>
			<p>Для базы данных обычно требуется комплексное программное обеспечение базы данных, известное как
				система управления базами данных (СУБД). СУБД служит интерфейсом между базой данных и ее конечными
				пользователями или программами, позволяя пользователям извлекать, обновлять и управлять организацией
				и оптимизацией информации. СУБД также облегчает контроль и управление базами данных, позволяя
				выполнять различные административные операции, такие как мониторинг производительности, настройка,
				резервное копирование и восстановление.</p>
		</div>
		<div>
			<h4>Компоненты</h4>
			<p>Вот некоторые общие компоненты, найденные в разных базах данных:</p>
			<div>
				<h5>Схема</h5>
				<p>Роль схемы состоит в том, чтобы определить форму структуры данных и указать, какие типы данных
					могут быть размещены. Схемы могут строго применяться ко всей базе данных, слабо применяться к
					части базы данных или вообще не существовать.</p>
			</div>
			<div>
				<h5>Стол</h5>
				<p>Каждая таблица содержит различные столбцы, как в электронной таблице. В таблице может быть всего
					два столбца и более сотни столбцов, в зависимости от типа информации, помещаемой в таблицу.</p>
			</div>
			<div>
				<h5>Столбец</h5>
				<p>Столбец содержит набор значений данных определенного типа, по одному значению для каждой строки
					базы данных. Столбец может содержать текстовые значения, числа, перечисления, метки времени и т. д.
				</p>
			</div>
			<div>
				<h5>Ряд</h5>
				<p>Данные в таблице записываются в строках. В таблице могут быть тысячи или миллионы строк,
					содержащих любую конкретную информацию.</p>
			</div>
		</div>
		<div>
			<h4>Типы</h4>
			<p>Ниже приведены различные типы баз данных:</p>
			<ul>
				<li><strong><a href="">SQL</a></strong></li>
				<li><strong><a href="">NoSQL</a></strong>
					<ul>
						<li>Документ</li>
						<li>Ключ-значение</li>
						<li>График</li>
						<li>Временная последовательность</li>
						<li>Широкая колонка</li>
						<li>Мультимодель</li>
					</ul>
				</li>
			</ul>
		</div>
		<div>
			<h4>Проблемы</h4>
			<p>Некоторые распространенные проблемы, возникающие при работе с базами данных в масштабе:</p>
			<ul>
				<li><strong>Поглощение значительного увеличения объема данных</strong>: взрыв данных, поступающих от
					датчиков, подключенных машин и десятков других источников.</li>
				<li><strong>Обеспечение безопасности данных</strong>: Утечки данных происходят повсеместно в наши дни,
					как никогда важно обеспечить безопасность данных, а также легкий доступ для пользователей.</li>
				<li><strong>Удовлетворение спроса</strong>: компаниям необходим доступ к своим данным в режиме
					реального времени, чтобы поддерживать своевременное принятие решений и использовать новые
					возможности.</li>
				<li><strong>Управление базой данных и инфраструктурой и их обслуживание</strong>: по мере усложнения
					баз данных и роста объемов данных компании сталкиваются с расходами на наем дополнительных
					специалистов для управления своими базами данных.</li>
				<li><strong>Снятие ограничений на масштабируемость</strong>: бизнес должен расти, если он хочет
					выжить, и его управление данными должно расти вместе с ним. Но очень сложно предсказать, какая
					емкость потребуется компании, особенно для локальных баз данных.</li>
				<li><strong>Обеспечение резидентности данных, суверенитета данных или требований к задержке</strong>:
					в некоторых организациях есть варианты использования, которые лучше подходят для работы в
					локальной среде. В таких случаях идеально подходят спроектированные системы, предварительно
					сконфигурированные и предварительно оптимизированные для работы с базой данных.</li>
			</ul>
		</div>
	</div>
	<div>
		<h3>базы данных SQL</h3>
		<p>База данных SQL (или реляционная) представляет собой набор элементов данных с предопределенными
			отношениями между ними. Эти элементы организованы в виде набора таблиц со столбцами и строками. Таблицы
			используются для хранения информации об объектах, которые должны быть представлены в базе данных. Каждый
			столбец в таблице содержит данные определенного типа, а поле хранит фактическое значение атрибута. Строки
			в таблице представляют набор связанных значений одного объекта или сущности.</p>
		<p>Каждая строка в таблице может быть помечена уникальным идентификатором, называемым первичным ключом, а
			строки в нескольких таблицах могут быть связаны с помощью внешних ключей. Доступ к этим данным можно
			получить различными способами без реорганизации самих таблиц базы данных. Базы данных SQL обычно следуют
			[модели согласованности ACID]</p>
		<div>
			<h4>Материализованные представления</h4>
			<p>Материализованное представление — это предварительно вычисленный набор данных, полученный из
				спецификации запроса и сохраненный для последующего использования. Поскольку данные предварительно
				вычисляются, выполнение запроса к материализованному представлению выполняется быстрее, чем выполнение
				запроса к базовой таблице представления. Эта разница в производительности может быть значительной,
				если запрос выполняется часто или является достаточно сложным.</p>
			<p>Он также позволяет создавать подмножества данных и повышает производительность сложных запросов,
				выполняемых с большими наборами данных, что снижает нагрузку на сеть. Существуют и другие способы
				использования материализованных представлений, но в основном они используются для повышения
				производительности и репликации.</p>
		</div>
		<div>
			<h4>Проблема с запросом N+1</h4>
			<p>Проблема с запросом N+1 возникает, когда уровень доступа к данным выполняет N дополнительных операторов
				SQL для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса.
				Чем больше значение N, тем больше запросов будет выполнено, тем больше влияние на производительность.</p>
			<p>Это обычно наблюдается в инструментах GraphQL и ORM (объектно-реляционное сопоставление) и может быть
				решено путем оптимизации SQL-запроса или использования загрузчика данных, который группирует
				последовательные запросы и делает один запрос данных скрытно.</p>
		</div>
		<div>
			<h4>Преимущества и недостатки</h4>
			<p>Давайте рассмотрим некоторые преимущества использования реляционных баз данных:</p>
			<ul>
				<li>Просто и точно</li>
				<li>Доступность</li>
				<li>Согласованность данных</li>
				<li>Гибкость</li>
			</ul>
			<h4>Недостатки</h4>
			<p>Ниже приведены недостатки реляционных баз данных:</p>
			<ul>
				<li>Дорогой в обслуживании</li>
				<li>Сложная эволюция схемы</li>
				<li>Повышение производительности (объединение, денормализация и т. д.)</li>
				<li>Трудно масштабировать из-за плохой горизонтальной масштабируемости</li>
			</ul>
		</div>
		<div>
			<h4>Примеры</h4>
			<p>Вот некоторые часто используемые реляционные базы данных:</p>
			<ul>
				<li><a href="https://www.postgresql.org">PostgreSQL</a></li>
				<li><a href="https://www.mysql.com">MySQL</a></li>
				<li><a href="https://mariadb.org">MariaDB</a></li>
				<li><a href="https://aws.amazon.com/rds/aurora">Амазонка Аврора</a></li>
			</ul>
		</div>
	</div>
	<div>
		<h3>базы данных NoSQL</h3>
		<p>NoSQL — это широкая категория, в которую входят любые базы данных, не использующие SQL в качестве
			основного языка доступа к данным. Эти типы баз данных также иногда называют нереляционными базами данных.
			В отличие от реляционных баз данных, данные в базе данных NoSQL не обязательно должны соответствовать
			заранее определенной схеме. Базы данных NoSQL следуют модели согласованности BASE</p>
		<p>Ниже приведены различные типы баз данных NoSQL:</p>
		<div>
			<h4>Документ</h4>
			<p>База данных документов (также известная как документно-ориентированная база данных или хранилище
				документов) — это база данных, в которой хранится информация в документах. Это базы данных общего
				назначения, которые служат различным вариантам использования как для транзакционных, так и для
				аналитических приложений.</p>
			<p><strong>Преимущества</strong></p>
			<ul>
				<li>Интуитивно понятный и гибкий</li>
				<li>Простое горизонтальное масштабирование</li>
				<li>Бессхемный</li>
			</ul>
			<p><strong>Недостатки</strong></p>
			<ul>
				<li>Бессхемный</li>
				<li>Нереляционный</li>
			</ul>
			<p><strong>Примеры</strong></p>
			<ul>
				<li><a href="https://www.mongodb.com">MongoDB</a></li>
				<li><a href="https://aws.amazon.com/documentdb">Amazon DocumentDB</a></li>
				<li><a href="https://couchdb.apache.org">CouchDB</a></li>
			</ul>
		</div>
		<div>
			<h4>Ключ-значение</h4>
			<p>Один из самых простых типов баз данных NoSQL, базы данных «ключ-значение» сохраняют данные в виде
				группы пар «ключ-значение», состоящей из двух элементов данных каждая. Их также иногда называют
				хранилищем ключей и значений.</p>
			<p><strong>Преимущества</strong></p>
			<ul>
				<li>Простой и производительный</li>
				<li>Высокая масштабируемость для больших объемов трафика</li>
				<li>Управление сеансом</li>
				<li>Оптимизирован поиск</li>
			</ul>
			<p><strong>Недостатки</strong></p>
			<ul>
				<li>Базовый CRUD</li>
				<li>Значения не могут быть отфильтрованы</li>
				<li>Не хватает возможностей индексации и сканирования</li>
				<li>Не оптимизирован для сложных запросов</li>
			</ul>
			<p><strong>Примеры</strong></p>
			<ul>
				<li><a href="https://redis.io">redis</a></li>
				<li><a href="https://memcached.org">Memcached</a></li>
				<li><a href="https://aws.amazon.com/dynamodb">Amazon DynamoDB</a></li>
				<li><a href="https://aerospike.com">Аэроспайк</a></li>
			</ul>
		</div>
		<div>
			<h4>График</h4>
			<p>База данных графа — это база данных NoSQL, которая использует структуры графа для семантических
				запросов с узлами, ребрами и свойствами для представления и хранения данных вместо таблиц или
				документов.</p>
			<p>Граф связывает элементы данных в хранилище с набором узлов и ребер, причем ребра представляют отношения
				между узлами. Отношения позволяют напрямую связывать данные в хранилище и во многих случаях извлекать
				их с помощью одной операции.</p>
			<p><strong>Преимущества</strong></p>
			<ul>
				<li>Скорость запроса</li>
				<li>Подвижный и гибкий</li>
				<li>Явное представление данных</li>
			</ul>
			<p><strong>Недостатки</strong></p>
			<ul>
				<li>Сложный</li>
				<li>Нет стандартизированного языка запросов</li>
			</ul>
			<p><strong>Случаи использования</strong></p>
			<ul>
				<li>Обнаружение мошенничества</li>
				<li>Рекомендованные двигатели</li>
				<li>Социальные сети</li>
				<li>Картирование сети</li>
			</ul>
			<p><strong>Примеры</strong></p>
			<ul>
				<li><a href="https://neo4j.com">Neo4j</a></li>
				<li><a href="https://www.arangodb.com">ArangoDB</a></li>
				<li><a href="https://aws.amazon.com/neptune">Амазон Нептун</a></li>
				<li><a href="https://janusgraph.org">ЯнусГраф</a></li>
			</ul>
		</div>
		<div>
			<h4>Временная последовательность</h4>
			<p>База данных временных рядов — это база данных, оптимизированная для данных с отметками времени или
				временных рядов.</p>
			<p><strong>Преимущества</strong></p>
			<ul>
				<li>Быстрая вставка и извлечение</li>
				<li>Эффективное хранение данных</li>
			</ul>
			<p><strong>Случаи использования</strong></p>
			<ul>
				<li>Данные Интернета вещей</li>
				<li>Анализ показателей</li>
				<li>Мониторинг приложений</li>
				<li>Понимание финансовых тенденций</li>
			</ul>
			<p><strong>Примеры</strong></p>
			<ul>
				<li><a href="https://www.influxdata.com">InfluxDB</a></li>
				<li><a href="https://druid.apache.org">Апач Друид</a></li>
			</ul>
		</div>
		<div>
			<h4>Широкая колонка</h4>
			<p>Базы данных с широкими столбцами, также известные как хранилища с широкими столбцами, не зависят от
				схемы. Данные хранятся в семействах столбцов, а не в строках и столбцах.</p>
			<p><strong>Преимущества</strong></p>
			<ul>
				<li>Высокая масштабируемость, может обрабатывать петабайты данных</li>
				<li>Идеально подходит для работы с большими данными в режиме реального времени.</li>
			</ul>
			<p><strong>Недостатки</strong></p>
			<ul>
				<li>Дорогой</li>
				<li>Увеличено время записи</li>
			</ul>
			<p><strong>Случаи использования</strong></p>
			<ul>
				<li>Бизнес-аналитика</li>
				<li>Хранение данных на основе атрибутов</li>
			</ul>
			<p><strong>Примеры</strong></p>
			<ul>
				<li><a href="https://cloud.google.com/bigtable">Большая таблица</a></li>
				<li><a href="https://cassandra.apache.org">cassandra apache</a></li>
				<li><a href="https://www.scylladb.com">ScyllaDB</a></li>
			</ul>
		</div>
		<div>
			<h4>Мультимодель</h4>
			<p>Базы данных с несколькими моделями объединяют различные модели баз данных (т. е. реляционные, графовые,
				ключ-значение, документ и т. д.) в единый интегрированный бэкэнд. Это означает, что они могут
				поддерживать различные типы данных, индексы, запросы и хранить данные более чем в одной модели.</p>
			<p><strong>Преимущества</strong></p>
			<ul>
				<li>Гибкость</li>
				<li>Подходит для сложных проектов</li>
				<li>Согласованность данных</li>
			</ul>
			<p><strong>Недостатки</strong></p>
			<ul>
				<li>Сложный</li>
				<li>Менее зрелый</li>
			</ul>
			<p><strong>Примеры</strong></p>
			<ul>
				<li><a href="https://www.arangodb.com">ArangoDB</a></li>
				<li><a href="https://azure.microsoft.com/en-in/services/cosmos-db">Azure Cosmos DB</a></li>
				<li><a href="https://www.couchbase.com">Couchbase</a></li>
			</ul>
		</div>
	</div>
	<div>
		<h3>Базы данных SQL и NoSQL</h3>
		<p>В мире баз данных существует два основных типа решений: базы данных SQL (реляционные) и базы данных NoSQL
			(нереляционные). Оба они отличаются тем, как они были построены, типом информации, которую они хранят,
			и тем, как они ее хранят. Реляционные базы данных структурированы и имеют предопределенные схемы, тогда
			как нереляционные базы данных неструктурированы, распределены и имеют динамическую схему.</p>
		<h4>Различия высокого уровня</h4>
		<p>Вот некоторые высокоуровневые различия между SQL и NoSQL:</p>
		<h5>Хранилище</h5>
		<p>SQL хранит данные в таблицах, где каждая строка представляет объект, а каждый столбец представляет точку
			данных об этом объекте.</p>
		<p>Базы данных NoSQL имеют разные модели хранения данных, такие как ключ-значение, граф, документ и т. д.</p>
		<h5>Схема</h5>
		<p>В SQL каждая запись соответствует фиксированной схеме, что означает, что столбцы должны быть определены и
			выбраны до ввода данных, и каждая строка должна иметь данные для каждого столбца. Схему можно изменить
			позже, но это требует изменения базы данных с помощью миграций.</p>
		<p>В то время как в NoSQL схемы являются динамическими. Поля можно добавлять на лету, и каждая <em>запись</em>
			(или ее эквивалент) не обязательно должна содержать данные для каждого <em>поля</em>.</p>
		<h5>Запрос</h5>
		<p>Базы данных SQL используют SQL (язык структурированных запросов) для определения данных и управления ими,
			что является очень мощным.</p>
		<p>В базе данных NoSQL запросы сосредоточены на наборе документов. Разные базы данных имеют разный синтаксис
			для запросов.</p>
		<h5>Масштабируемость</h5>
		<p>В большинстве распространенных ситуаций базы данных SQL масштабируются по вертикали, что может стать очень
			дорогим. Можно масштабировать реляционную базу данных на несколько серверов, но это сложный и трудоемкий
			процесс.</p>
		<p>С другой стороны, базы данных NoSQL являются горизонтально масштабируемыми, что означает, что мы можем легко
			добавить больше серверов в нашу инфраструктуру базы данных NoSQL для обработки большого трафика. Базы данных
			NoSQL можно размещать на любом дешевом товарном оборудовании или в облачных средах, что делает его намного
			более рентабельным, чем вертикальное масштабирование. Многие технологии NoSQL также автоматически
			распределяют данные между серверами.</p>
		<h5>Надежность</h5>
		<p>Подавляющее большинство реляционных баз данных совместимы с ACID. Таким образом, когда речь идет о
			надежности данных и надежной гарантии выполнения транзакций, базы данных SQL по-прежнему являются
			лучшим выбором.</p>
		<p>Большинство решений NoSQL жертвуют совместимостью с ACID ради производительности и масштабируемости.</p>
		<h4>Причины</h4>
		<p>Как всегда, мы всегда должны выбирать технологию, которая лучше соответствует требованиям. Итак, давайте
			рассмотрим некоторые причины выбора базы данных на основе SQL или NoSQL:</p>
		<p><strong>Для SQL</strong></p>
		<ul>
			<li>Структурированные данные со строгой схемой</li>
			<li>Реляционные данные</li>
			<li>Необходимость сложных соединений</li>
			<li>Транзакции</li>
			<li>Поиск по индексу очень быстрый</li>
		</ul>
		<p><strong>Для NoSQL</strong></p>
		<ul>
			<li>Динамическая или гибкая схема</li>
			<li>Нереляционные данные</li>
			<li>Нет необходимости в сложных соединениях</li>
			<li>Очень интенсивная работа с данными</li>
			<li>Очень высокая пропускная способность для IOPS</li>
		</ul>
		<h3>Репликация базы данных</h3>
		<p>Репликация — это процесс, который включает обмен информацией для обеспечения согласованности между
			избыточными ресурсами, такими как несколько баз данных, для повышения надежности, отказоустойчивости
			или доступности.</p>
		<h4>Мастер-ведомая репликация</h4>
		<p>Мастер обслуживает чтение и запись, реплицируя запись на один или несколько ведомых устройств, которые
			обслуживают только чтение. Ведомые устройства также могут копировать дополнительных подчиненных устройств
			в виде дерева. Если ведущий отключается, система может продолжать работать в режиме только для чтения
			до тех пор, пока ведомый не будет повышен до ведущего или не будет подготовлен новый ведущий.</p>
		<h5>Преимущества</h5>
		<ul>
			<li>Бэкапы всей базы относительно не влияют на мастер.</li>
			<li>Приложения могут читать с ведомых устройств, не влияя на ведущее устройство.</li>
			<li>Ведомые могут быть переведены в автономный режим и синхронизированы с мастером без простоев.</li>
		</ul>
		<h5>Недостатки</h5>
		<ul>
			<li>Репликация добавляет больше оборудования и дополнительную сложность.</li>
			<li>Время простоя и возможная потеря данных при сбое мастера.</li>
			<li>Все операции записи также должны производиться на ведущее устройство в архитектуре ведущий-ведомый.</li>
			<li>Чем больше ведомых устройств чтения, тем больше нам придется реплицировать, что увеличит задержку
				репликации.</li>
		</ul>
		<h4>Репликация мастер-мастер</h4>
		<p>Оба мастера обслуживают операции чтения/записи и координируют друг с другом. Если один из мастеров
			выходит из строя, система может продолжать работать как с чтением, так и с записью.</p>
		<h5>Преимущества</h5>
		<ul>
			<li>Приложения могут читать с обоих мастеров.</li>
			<li>Распределяет нагрузку записи между обоими главными узлами.</li>
			<li>Простой, автоматический и быстрый переход на другой ресурс.</li>
		</ul>
		<h5>Недостатки</h5>
		<ul>
			<li>Не так просто, как master-slave для настройки и развертывания.</li>
			<li>Либо слабо согласованы, либо имеют увеличенную задержку записи из-за синхронизации.</li>
			<li>Разрешение конфликтов вступает в игру по мере добавления дополнительных узлов записи и увеличения
				задержки.</li>
		</ul>
		<h4>Синхронная и асинхронная репликация</h4>
		<p>Основное различие между синхронной и асинхронной репликацией заключается в том, как данные записываются в
			реплику. При синхронной репликации данные записываются в основное хранилище и реплику одновременно.
			Таким образом, первичная копия и реплика всегда должны оставаться синхронизированными.</p>
		<p>Напротив, асинхронная репликация копирует данные в реплику после того, как данные уже записаны в основное
			хранилище. Хотя процесс репликации может происходить практически в режиме реального времени, чаще
			репликация выполняется по расписанию, что является более экономичным.</p>
		<h3>Индексы</h3>
		<p>Индексы хорошо известны, когда речь идет о базах данных, они используются для повышения скорости операций
			поиска данных в хранилище данных. Индекс компенсирует увеличение накладных расходов на хранение и более
			медленную запись (поскольку нам нужно не только записывать данные, но и обновлять индекс) в пользу более
			быстрого чтения. Индексы используются для быстрого поиска данных без проверки каждой строки в таблице
			базы данных. Индексы могут быть созданы с использованием одного или нескольких столбцов таблицы базы
			данных, обеспечивая основу как для быстрого случайного поиска, так и для эффективного доступа к
			упорядоченным записям.</p>
		<p>Индекс — это структура данных, которую можно воспринимать как оглавление, указывающее нам место, где
			находятся фактические данные. Поэтому, когда мы создаем индекс для столбца таблицы, мы сохраняем этот
			столбец и указатель на всю строку в индексе. Индексы также используются для создания разных
			представлений одних и тех же данных. Для больших наборов данных это отличный способ указать различные
			фильтры или схемы сортировки, не прибегая к созданию нескольких дополнительных копий данных.</p>
		<p>Одно качество, которым могут обладать индексы базы данных, заключается в том, что они могут быть <strong>
			плотными</strong> или <strong>разреженными</strong>. Каждое из этих качеств индекса имеет свои
			собственные компромиссы. Давайте посмотрим, как будет работать каждый тип индекса:</p>
		<h4>Плотный индекс</h4>
		<p>В плотном индексе запись индекса создается для каждой строки таблицы. Записи могут быть расположены
			напрямую, поскольку каждая запись индекса содержит значение ключа поиска и указатель на фактическую
			запись.</p>
		<p>Плотные индексы требуют большего обслуживания, чем разреженные индексы во время записи. Поскольку в
			каждой строке должна быть запись, база данных должна поддерживать индекс для вставок, обновлений и
			удалений. Наличие записи для каждой строки также означает, что для плотных индексов потребуется больше
			памяти. Преимущество плотного индекса в том, что значения можно быстро найти с помощью бинарного
			поиска. Плотные индексы также не предъявляют никаких требований к упорядочению данных.</p>
		<h4>Разреженный индекс</h4>
		<p>В разреженном индексе записи создаются только для некоторых записей.</p>
		<p>Разреженные индексы требуют меньше обслуживания, чем плотные индексы во время записи, поскольку они
			содержат только подмножество значений. Это меньшее бремя обслуживания означает, что вставки, обновления
			и удаления будут выполняться быстрее. Меньшее количество записей также означает, что индекс будет
			использовать меньше памяти. Поиск данных происходит медленнее, поскольку сканирование страницы обычно
			следует за бинарным поиском. Разреженные индексы также необязательны при работе с упорядоченными данными.</p>
		<h3>Нормализация и Денормализация</h3>
		<h4>Условия</h4>
		<p>Прежде чем мы пойдем дальше, давайте рассмотрим некоторые часто используемые термины нормализации и
			денормализации.</p>
		<h5>Ключи</h5>
		<p><strong>Первичный ключ</strong>: столбец или группа столбцов, которые можно использовать для уникальной
			идентификации каждой строки таблицы.</p>
		<p><strong>Составной ключ</strong>: первичный ключ, состоящий из нескольких столбцов.</p>
		<p><strong>Суперключ</strong>: набор всех ключей, которые могут однозначно идентифицировать все строки,
			присутствующие в таблице.</p>
		<p><strong>Ключ-кандидат</strong>: атрибуты, однозначно идентифицирующие строки в таблице.</p>
		<p><strong>Внешний ключ</strong>: это ссылка на первичный ключ другой таблицы.</p>
		<p><strong>Альтернативный ключ</strong>. Ключи, не являющиеся первичными, называются альтернативными
			ключами.</p>
		<p><strong>Суррогатный ключ</strong>: генерируемое системой значение, которое однозначно идентифицирует
			каждую запись в таблице, если ни один другой столбец не может содержать свойства первичного ключа.</p>
		<h5>Зависимости</h5>
		<p><strong>Частичная зависимость</strong>: возникает, когда первичный ключ определяет некоторые другие
			атрибуты.</p>
		<p><strong>Функциональная зависимость</strong>: это отношение, которое существует между двумя атрибутами,
			обычно между первичным ключом и неключевым атрибутом в таблице.</p>
		<p><strong>Транзитивная функциональная зависимость</strong>: возникает, когда какой-то неключевой атрибут
			определяет какой-то другой атрибут.</p>
		<h5>Аномалии</h5>
		<p>Аномалия базы данных возникает, когда в базе данных есть недостаток из-за неправильного планирования
			или хранения всего в плоской базе данных. Обычно это решается путем нормализации.</p>
		<p>Существует три типа аномалий базы данных:</p>
		<p><strong>Аномалия вставки</strong>: возникает, когда мы не можем вставить определенные атрибуты в базу
			данных без наличия других атрибутов.</p>
		<p><strong>Аномалия обновления</strong>: возникает в случае избыточности данных и частичного обновления.
			Другими словами, правильное обновление базы данных требует других действий, таких как добавление,
			удаление или и то, и другое.</p>
		<p><strong>Аномалия удаления</strong>: возникает, когда удаление одних данных требует удаления других данных.</p>
		<p><strong>Пример</strong></p>
		<p>Рассмотрим следующую ненормализованную таблицу:</p>
		<table class="table table--striped table--bordered">
			<thead>
			<tr>
				<th>ID</th>
				<th>Имя</th>
				<th>Роль</th>
				<th>Команда</th>
			</tr>
			</thead>
			<tbody>
			<tr>
				<td>1</td>
				<td>Питер</td>
				<td>Инженер-программист</td>
				<td>А</td>
			</tr>
			<tr>
				<td>2</td>
				<td>Брайан</td>
				<td>DevOps-инженер</td>
				<td>Б</td>
			</tr>
			<tr>
				<td>3</td>
				<td>Хейли</td>
				<td>Менеджер по продукту</td>
				<td>С</td>
			</tr>
			<tr>
				<td>4</td>
				<td>Хейли</td>
				<td>Менеджер по продукту</td>
				<td>С</td>
			</tr>
			<tr>
				<td>5</td>
				<td>Стив</td>
				<td>Фронтенд-инженер</td>
				<td>Д</td>
			</tr>
			</tbody>
		</table>
		<p>Давайте представим, мы наняли нового человека «Джон», но ему не сразу дали команду. Это вызовет <em>
			аномалию вставки</em>, так как атрибут команды еще не присутствует.</p>
		<p>Далее, предположим, что Хейли из команды C получила повышение, чтобы отразить это изменение в базе данных,
			нам нужно будет обновить 2 строки для обеспечения согласованности, что может вызвать <em>аномалию
				обновления</em>.</p>
		<p>Наконец, мы хотели бы удалить команду B, но для этого нам также потребуется удалить дополнительную
			информацию, такую как имя и роль, это пример <em>аномалии удаления</em>.</p>
		<h4>Нормализация</h4>
		<p>Нормализация — это процесс организации данных в базе данных. Это включает в себя создание таблиц и
			установление отношений между этими таблицами в соответствии с правилами, предназначенными как для
			защиты данных, так и для повышения гибкости базы данных за счет устранения избыточности и непоследовательной
			зависимости.</p>
		<h5>Зачем нужна нормализация?</h5>
		<p>Цель нормализации — устранить избыточные данные и обеспечить согласованность данных. Полностью
			нормализованная база данных позволяет расширять ее структуру для размещения новых типов данных без
			слишком большого изменения существующей структуры. В результате приложения, взаимодействующие с базой
			данных, затрагиваются минимально.</p>
		<h5>Нормальные формы</h5>
		<p>Нормальные формы представляют собой набор рекомендаций, обеспечивающих нормализацию базы данных. Давайте
			обсудим некоторые важные нормальные формы:</p>
		<p><strong>1NF</strong></p>
		<p>Чтобы таблица находилась в первой нормальной форме (1НФ), она должна соответствовать следующим правилам:</p>
		<ul>
			<li>Повторяющиеся группы не допускаются.</li>
			<li>Определите каждый набор связанных данных с помощью первичного ключа.</li>
			<li>Набор связанных данных должен иметь отдельную таблицу.</li>
			<li>Смешивание типов данных в одном столбце не допускается.</li>
		</ul>
		<p><strong>2НФ</strong></p>
		<p>Чтобы таблица находилась во второй нормальной форме (2НФ), она должна соответствовать следующим правилам:</p>
		<ul>
			<li>Удовлетворяет первой нормальной форме (1НФ).</li>
			<li>Не должно быть частичной зависимости.</li>
		</ul>
		<p><strong>3NF</strong></p>
		<p>Чтобы таблица находилась в третьей нормальной форме (3НФ), она должна соответствовать следующим правилам:</p>
		<ul>
			<li>Удовлетворяет второй нормальной форме (2НФ).</li>
			<li>Транзитивные функциональные зависимости не допускаются.</li>
		</ul>
		<p><strong>БКНФ</strong></p>
		<p>Нормальная форма Бойса-Кодда (или BCNF) — это немного усиленная версия третьей нормальной формы (3NF),
			используемая для устранения определенных типов аномалий, с которыми не имеет дело 3NF, как первоначально
			определено. Иногда его также называют нормальной формой 3,5 (3,5NF).</p>
		<p>Чтобы таблица находилась в нормальной форме Бойса-Кодда (BCNF), она должна соответствовать следующим
			правилам:</p>
		<ul>
			<li>Выполняется третья нормальная форма (3NF).</li>
			<li>Для каждой функциональной зависимости X → Y, X должен быть суперключом.</li>
		</ul>
		<p><em>Есть более нормальные формы, такие как 4NF, 5NF и 6NF, но мы не будем их здесь обсуждать. Посмотрите
			это <a href="https://www.youtube.com/watch?v=GFQaEYEc8_8">потрясающее видео</a>, в котором подробно
			рассказывается.</em></p>
		<p>В реляционной базе данных отношение часто называют «нормализованным"_, если оно соответствует третьей
			нормальной форме. Большинство отношений 3NF свободны от аномалий вставки, обновления и удаления.</p>
		<p>Как и во многих формальных правилах и спецификациях, реальные сценарии не всегда обеспечивают идеальное
			соответствие. Если вы решите нарушить одно из первых трех правил нормализации, убедитесь, что ваше
			приложение предвидит любые проблемы, которые могут возникнуть, такие как избыточные данные и
			несогласованные зависимости.</p>
		<h5>Преимущества</h5>
		<p>Вот некоторые преимущества нормализации:</p>
		<ul>
			<li>Уменьшает избыточность данных.</li>
			<li>Улучшенный дизайн данных.</li>
			<li>Повышает согласованность данных.</li>
			<li>Обеспечивает ссылочную целостность.</li>
		</ul>
		<h5>Недостатки</h5>
		<p>Давайте рассмотрим некоторые недостатки нормализации:</p>
		<ul>
			<li>Дизайн данных сложен.</li>
			<li>Более низкая производительность.</li>
			<li>Накладные расходы на техническое обслуживание.</li>
			<li>Требовать больше соединений.</li>
		</ul>
		<h4>Денормализация</h4>
		<p>Денормализация — это метод оптимизации базы данных, при котором мы добавляем избыточные данные в одну
			или несколько таблиц. Это может помочь нам избежать дорогостоящих соединений в реляционной базе данных.
			Он пытается улучшить производительность чтения за счет некоторой производительности записи. Избыточные
			копии данных записываются в несколько таблиц, чтобы избежать дорогостоящих объединений.</p>
		<p>Как только данные распределяются с помощью таких методов, как федерация и сегментирование, управление
			соединениями по сети еще более усложняется. Денормализация может обойти необходимость в таких сложных
			соединениях.</p>
		<p><em>Примечание. Денормализация не означает отмену нормализации.</em></p>
		<h5>Преимущества</h5>
		<p>Давайте рассмотрим некоторые преимущества денормализации:</p>
		<ul>
			<li>Получение данных быстрее.</li>
			<li>Писать запросы проще.</li>
			<li>Сокращение количества столов.</li>
			<li>Удобен в управлении.</li>
		</ul>
		<h5>Недостатки</h5>
		<p>Ниже приведены некоторые недостатки денормализации:</p>
		<ul>
			<li>Дорогие вставки и обновления.</li>
			<li>Увеличивает сложность проектирования базы данных.</li>
			<li>Увеличивает избыточность данных.</li>
			<li>Больше шансов на несоответствие данных.</li>
		</ul>
		<h3>Модели согласованности ACID и BASE</h3>
		<p>Давайте обсудим модели согласованности ACID и BASE.</p>
		<h4>КИСЛОТА</h4>
		<p>Термин ACID означает атомарность, согласованность, изоляцию и долговечность. Свойства ACID используются
			для поддержания целостности данных во время обработки транзакций.</p>
		<p>Чтобы поддерживать согласованность до и после транзакции, реляционные базы данных следуют свойствам ACID.
			Давайте разберемся в этих терминах:</p>
		<h5>Атомный</h5>
		<p>Все операции в транзакции завершаются успешно или каждая операция откатывается.</p>
		<h5>Последовательный</h5>
		<p>По завершении транзакции база данных является структурно прочной.</p>
		<h5>Изолированный</h5>
		<p>Транзакции не конфликтуют друг с другом. Состязательный доступ к данным контролируется базой данных,
			поэтому транзакции выполняются последовательно.</p>
		<h5>Прочный</h5>
		<p>После завершения транзакции и записи на диск записей и обновлений он останется в системе, даже если
			произойдет системный сбой.</p>
		<h4>БАЗА</h4>
		<p>С увеличением объема данных и требований к высокой доступности кардинально изменился и подход к
			проектированию баз данных. Чтобы увеличить возможности масштабирования и в то же время быть
			высокодоступными, мы переносим логику из базы данных на отдельные серверы. Таким образом, база данных
			становится более независимой и фокусируется на фактическом процессе хранения данных.</p>
		<p>В мире баз данных NoSQL транзакции ACID менее распространены, поскольку некоторые базы данных ослабили
			требования к немедленной согласованности, актуальности данных и точности, чтобы получить другие
			преимущества, такие как масштабируемость и отказоустойчивость.</p>
		<p>Свойства BASE намного свободнее, чем гарантии ACID, но между двумя моделями согласованности нет прямого
			соответствия один к одному. Давайте разберемся в этих терминах:</p>
		<h5>Базовая доступность</h5>
		<p>База данных работает большую часть времени.</p>
		<h5>Мягкое состояние</h5>
		<p>Хранилища не должны быть согласованными по записи, а разные реплики не должны быть все время взаимно
			согласованными.</p>
		<h5>Конечная согласованность</h5>
		<p>Данные могут быть несогласованными сразу, но в конечном итоге они становятся непротиворечивыми. Чтения в
			системе по-прежнему возможны, даже если они могут не давать правильный ответ из-за несогласованности.</p>
		<h4>ACID против BASE Компромиссы</h4>
		<p>Нет правильного ответа на вопрос, нужна ли нашему приложению модель согласованности ACID или BASE. Обе
			модели были разработаны для удовлетворения различных требований. При выборе базы данных мы должны
			помнить о свойствах как моделей, так и о требованиях нашего приложения.</p>
		<p>Учитывая слабую согласованность BASE, разработчикам необходимо быть более осведомленными и тщательными
			в отношении непротиворечивых данных, если они выбирают хранилище BASE для своего приложения. Очень
			важно знать поведение BASE выбранной базы данных и работать в рамках этих ограничений.</p>
		<p>С другой стороны, планирование с учетом ограничений BASE иногда может быть серьезным недостатком по
			сравнению с простотой транзакций ACID. Полная база данных ACID идеально подходит для случаев, когда
			важны надежность и согласованность данных.</p>
		<h3>Теорема CAP</h3>
		<p>Теорема CAP утверждает, что распределенная система может обеспечить только две из трех желаемых
			характеристик: согласованность, доступность и устойчивость к разделам (CAP).</p>
		<p>Давайте подробно рассмотрим три характеристики распределенной системы, на которые ссылается теорема CAP.</p>
		<h5>Последовательность</h5>
		<p>Согласованность означает, что все клиенты видят одни и те же данные одновременно, независимо от того,
			к какому узлу они подключаются. Чтобы это произошло, всякий раз, когда данные записываются на один узел,
			они должны быть немедленно перенаправлены или реплицированы на все узлы в системе, прежде чем запись
			будет считаться «успешной».</p>
		<h5>Доступность</h5>
		<p>Доступность означает, что любой клиент, выполняющий запрос данных, получает ответ, даже если один или
			несколько узлов не работают.</p>
		<h5>Допуск разделения</h5>
		<p>Устойчивость к разделам означает, что система продолжает работать, несмотря на потерю сообщений или
			частичный сбой. Система, устойчивая к разделам, может выдержать любой сбой сети, который не приведет к
			сбою всей сети. Данные в достаточной степени реплицируются между комбинациями узлов и сетей, чтобы
			поддерживать работоспособность системы при периодических сбоях.</p>
		<h4>Компромисс между согласованностью и доступностью</h4>
		<p>Мы живем в физическом мире и не можем гарантировать стабильность сети, поэтому распределенные базы данных
			должны выбирать Partition Tolerance (P). Это подразумевает компромисс между согласованностью © и
			доступностью (A).</p>
		<h5>База ЦС</h5>
		<p>База данных ЦС обеспечивает согласованность и доступность на всех узлах. Он не может этого сделать, если
			между любыми двумя узлами в системе есть раздел, и поэтому не может обеспечить отказоустойчивость.</p>
		<p><strong>Пример</strong>: <a href="https://www.postgresql.org">PostgreSQL</a>, <a href="https://mariadb.org">
			MariaDB</a>.</p>
		<h5>База данных CP</h5>
		<p>База данных CP обеспечивает согласованность и устойчивость к разделам за счет доступности. Когда между
			любыми двумя узлами возникает разделение, система должна отключить несогласованный узел до тех пор,
			пока разделение не будет разрешено.</p>
		<p><strong>Пример</strong>: <a href="https://www.mongodb.com">MongoDB</a>, <a href="https://hbase.apache.org">
			Apache HBase</a>.</p>
		<h5>База данных точек доступа</h5>
		<p>База данных AP обеспечивает доступность и устойчивость к разделам за счет согласованности. Когда
			происходит разделение, все узлы остаются доступными, но те, которые находятся на неправильном конце
			раздела, могут возвращать более старую версию данных, чем другие. Когда раздел разрешен, базы данных
			AP обычно повторно синхронизируют узлы, чтобы исправить все несоответствия в системе.</p>
		<p><strong>Пример</strong>: <a href="https://cassandra.apache.org">Apache Cassandra</a>,
			<a href="https://couchdb.apache.org">CouchDB</a>.</p>
		<h3>Теорема PACELC</h3>
		<p>Теорема PACELC является расширением теоремы CAP. Теорема CAP утверждает, что в случае разделения сети (P)
			в распределенной системе необходимо выбирать между доступностью (A) и согласованностью ©.</p>
		<p>PACELC расширяет теорему CAP, вводя задержку (L) в качестве дополнительного атрибута распределенной
			системы. Теорема утверждает, что иначе (E), даже когда система работает нормально при отсутствии разделов,
			приходится выбирать между задержкой (L) и согласованностью ©.</p>
		<p><em>Теорема PACELC была впервые описана <a href="https://scholar.google.com/citations?user=zxeEF2gAAAAJ">
			Дэниелом Дж. Абади</a>.</em></p>
		<p>Теорема PACELC была разработана для устранения ключевого ограничения теоремы CAP, поскольку она не
			учитывает производительность или задержку.</p>
		<p>Например, согласно теореме CAP база данных может считаться доступной, если запрос возвращает ответ
			через 30 дней. Очевидно, что такая задержка неприемлема для любого реального приложения.</p>
		<h3>транзакций</h3>
		<p>Транзакция — это серия операций с базой данных, которые считаются «единой единицей работы»_. Операции в
			транзакции либо завершаются успешно, либо завершаются ошибкой. Таким образом, понятие транзакции
			поддерживает целостность данных, когда часть системы дает сбой. Не все базы данных выбирают поддержку
			транзакций ACID, обычно потому, что они отдают приоритет другим оптимизациям, которые сложно или
			теоретически невозможно реализовать вместе.</p>
		<p><em>Обычно реляционные базы данных поддерживают ACID-транзакции, а нереляционные базы данных — нет
			(есть исключения).</em></p>
		<h4>Состояния</h4>
		<p>Транзакция в базе данных может находиться в одном из следующих состояний:</p>
		<h5>Активный</h5>
		<p>В этом состоянии транзакция выполняется. Это начальное состояние каждой транзакции.</p>
		<h5>Частично совершено</h5>
		<p>Когда транзакция выполняет свою последнюю операцию, говорят, что она находится в частично
			зафиксированном состоянии.</p>
		<h5>Преданный идее</h5>
		<p>Если транзакция успешно выполняет все свои операции, говорят, что она зафиксирована. Все его эффекты
			теперь навсегда установлены в системе баз данных.</p>
		<h5>Неуспешный</h5>
		<p>О транзакции говорят, что она находится в состоянии сбоя, если какая-либо из проверок, выполненных
			системой восстановления базы данных, не удалась. Неудачная транзакция больше не может продолжаться дальше.</p>
		<h5>Прервано</h5>
		<p>Если какая-либо из проверок завершилась неудачно и транзакция достигла состояния сбоя, то диспетчер
			восстановления отменяет все свои операции записи в базу данных, чтобы вернуть базу данных в исходное
			состояние, в котором она находилась до выполнения транзакции. Транзакции в этом состоянии прерываются.</p>
		<p>Модуль восстановления базы данных может выбрать одну из двух операций после прерывания транзакции:</p>
		<ul>
			<li>Перезапустить транзакцию</li>
			<li>Убить транзакцию</li>
		</ul>
		<h5>Прекращено</h5>
		<p>Если отката нет или транзакция выходит из <em>совершенного состояния</em>, то система непротиворечива и
			готова к новой транзакции, а старая транзакция завершается.</p>
		<h3>Распределенные транзакции</h3>
		<p>Распределенная транзакция — это набор операций над данными, которые выполняются в двух или более базах
			данных. Обычно он координируется между отдельными узлами, соединенными сетью, но может также охватывать
			несколько баз данных на одном сервере.</p>
		<h4>Зачем нужны распределенные транзакции?</h4>
		<p>В отличие от транзакции ACID в одной базе данных, распределенная транзакция включает изменение данных в
			нескольких базах данных. Следовательно, распределенная обработка транзакций более сложна, поскольку база
			данных должна координировать фиксацию или откат изменений в транзакции как автономная единица.</p>
		<p>Другими словами, все узлы должны зафиксироваться, иначе все должны прерваться и вся транзакция откатится.
			Вот почему нам нужны распределенные транзакции.</p>
		<p>Теперь давайте рассмотрим некоторые популярные решения для распределенных транзакций:</p>
		<h4>Двухэтапная фиксация</h4>
		<p>Протокол двухфазной фиксации (2PC) — это распределенный алгоритм, который координирует все процессы,
			участвующие в распределенной транзакции, в отношении того, следует ли фиксировать или прерывать
			(откатывать) транзакцию.</p>
		<p>Этот протокол достигает своей цели даже во многих случаях временного сбоя системы и поэтому широко
			используется. Однако он не устойчив ко всем возможным конфигурациям отказов, и в редких случаях для
			исправления результата требуется ручное вмешательство.</p>
		<p>Для этого протокола требуется узел-координатор, который в основном координирует и контролирует
			транзакцию между различными узлами. Координатор пытается установить консенсус между набором процессов
			в два этапа, отсюда и название.</p>
		<h5>Фазы</h5>
		<p>Двухэтапная фиксация состоит из следующих фаз:</p>
		<p><strong>Подготовка</strong></p>
		<p>На этапе подготовки узел-координатор собирает консенсус от каждого из узлов-участников. Транзакция будет
			прервана, если каждый из узлов не ответит, что они <em>подготовлены</em>.</p>
		<p><strong>Фаза фиксации</strong></p>
		<p>Если все участники отвечают координатору, что они <em>подготовлены</em>, то координатор просит все узлы
			зафиксировать транзакцию. В случае сбоя транзакция будет отменена.</p>
		<h5>Проблемы</h5>
		<p>В протоколе двухэтапной фиксации могут возникнуть следующие проблемы:</p>
		<ul>
			<li>А если один из узлов выйдет из строя?</li>
			<li>А если сам координатор рухнет?</li>
			<li>Это блокирующий протокол.</li>
		</ul>
		<h4>Трехэтапная фиксация</h4>
		<p>Трехфазная фиксация (3PC) — это расширение двухфазной фиксации, в котором фаза фиксации разделена на две
			фазы. Это помогает решить проблему блокировки, возникающую в протоколе двухфазной фиксации.</p>
		<h5>Фазы</h5>
		<p>Трехэтапная фиксация состоит из следующих фаз:</p>
		<p><strong>Подготовка</strong></p>
		<p>Эта фаза аналогична двухфазной фиксации.</p>
		<p><strong>Фаза перед фиксацией</strong></p>
		<p>Координатор выдает сообщение перед фиксацией, и все участвующие узлы должны его подтвердить. Если участник
			не получает это сообщение вовремя, то транзакция прерывается.</p>
		<p><strong>Фаза фиксации</strong></p>
		<p>Этот шаг также аналогичен протоколу двухэтапной фиксации.</p>
		<h5>Чем полезен этап Pre-commit?</h5>
		<p>На этапе предварительной фиксации выполняется следующее:</p>
		<ul>
			<li>Если в этой фазе найдены узлы-участники, это означает, что <em>каждый</em> участник завершил первую
				фазу. Завершение фазы подготовки гарантировано.</li>
			<li>Каждая фаза теперь может истечь по тайм-ауту и избежать неопределенного ожидания.</li>
		</ul>
		<h4>Саги</h4>
		<p>Сага — это последовательность локальных транзакций. Каждая локальная транзакция обновляет базу данных и
			публикует сообщение или событие, чтобы инициировать следующую локальную транзакцию в саге. Если локальная
			транзакция терпит неудачу из-за нарушения бизнес-правила, сага выполняет серию компенсирующих транзакций,
			которые отменяют изменения, внесенные предыдущими локальными транзакциями.</p>
		<h5>Координация</h5>
		<p>Существует два распространенных подхода к реализации:</p>
		<ul>
			<li><strong>Хореография</strong>: каждая локальная транзакция публикует события домена, которые запускают
				локальные транзакции в других службах.</li>
			<li><strong>Оркестрация</strong>: оркестратор сообщает участникам, какие локальные транзакции выполнять.</li>
		</ul>
		<h5>Проблемы</h5>
		<ul>
			<li>Шаблон Saga особенно сложно отлаживать.</li>
			<li>Существует риск циклической зависимости между участниками саги.</li>
			<li>Отсутствие изоляции данных участников создает проблемы с надежностью.</li>
			<li>Тестирование затруднено, поскольку для имитации транзакции должны быть запущены все службы.</li>
		</ul>
		<h3>Шардинг</h3>
		<p>Прежде чем мы обсудим шардинг, давайте поговорим о разбиении данных:</p>
		<h4>Разделение данных</h4>
		<p>Разделение данных — это способ разбить базу данных на множество более мелких частей. Это процесс разделения
			базы данных или таблицы на несколько компьютеров для улучшения управляемости, производительности и
			доступности базы данных.</p>
		<h5>Методы</h5>
		<p>Существует множество различных способов, которыми можно было бы воспользоваться, чтобы решить, как разбить
			базу данных приложения на несколько более мелких БД. Ниже приведены два наиболее популярных метода,
			используемых различными крупномасштабными приложениями:</p>
		<p><strong>Горизонтальное разбиение (или сегментирование)</strong></p>
		<p>В этой стратегии мы разбиваем данные таблицы по горизонтали на основе диапазона значений, определяемого
			<em>partition key</em>. Его также называют <strong><em>сегментированием базы данных</em></strong>.</p>
		<p><strong>Вертикальное разбиение</strong></p>
		<p>При вертикальном разделении мы разделяем данные вертикально на основе столбцов. Мы делим таблицы на
			относительно меньшие таблицы с небольшим количеством элементов, и каждая часть присутствует в отдельном
			разделе.</p>
		<p>В этом уроке мы сосредоточимся на шардинге.</p>
		<h4>Что такое шардинг?</h4>
		<p>Разделение — это шаблон архитектуры базы данных, связанный с <em>горизонтальным разделением</em>, которое
			представляет собой практику разделения строк одной таблицы на несколько разных таблиц, известных как
			<em>partitions</em> или <em>shards</em>. Каждый раздел имеет одинаковую схему и столбцы, а также
			подмножество общих данных. Точно так же данные, хранящиеся в каждом разделе, уникальны и не зависят
			от данных, хранящихся в других разделах.</p>
		<p>Обоснование сегментирования данных заключается в том, что после определенного момента становится дешевле и
			целесообразнее масштабировать по горизонтали, добавляя больше машин, чем масштабировать по вертикали,
			добавляя мощные серверы. Разделение может быть реализовано как на уровне приложения, так и на уровне базы
			данных.</p>
		<h4>Критерий разделения</h4>
		<p>Существует большое количество критериев для разделения данных. Некоторые наиболее часто используемые
			критерии:</p>
		<h5>На основе хэша</h5>
		<p>Эта стратегия делит строки на разные секции на основе алгоритма хеширования, а не группирует строки базы
			данных на основе непрерывных индексов.</p>
		<p>Недостатком этого метода является то, что динамическое добавление/удаление серверов баз данных становится
			дорогостоящим.</p>
		<h5>На основе списка</h5>
		<p>При секционировании на основе списка каждая секция определяется и выбирается на основе списка значений
			столбца, а не набора смежных диапазонов значений.</p>
		<h5>На основе диапазона</h5>
		<p>Разделение по диапазонам сопоставляет данные с различными разделами на основе диапазонов значений ключа
			разделения. Другими словами, мы разбиваем таблицу таким образом, чтобы каждая секция содержала строки в
			заданном диапазоне, определяемом ключом секции.</p>
		<p>Диапазоны должны быть непрерывными, но не перекрывающимися, где каждый диапазон указывает не включающую
			нижнюю и верхнюю границу для раздела. Любые значения ключа разделения, равные или превышающие верхнюю
			границу диапазона, добавляются к следующему разделу.</p>
		<h5>Композитный</h5>
		<p>Как следует из названия, составное секционирование разделяет данные на основе двух или более методов
			секционирования. Здесь мы сначала разделяем данные, используя один метод, а затем каждый раздел далее
			подразделяется на подразделы, используя тот же или какой-либо другой метод.</p>
		<h4>Преимущества</h4>
		<p>Но зачем нам шардинг? Вот некоторые преимущества:</p>
		<ul>
			<li><strong>Доступность</strong>: обеспечивает логическую независимость многораздельной базы данных,
				обеспечивая высокую доступность нашего приложения. Здесь отдельными разделами можно управлять
				независимо.</li>
			<li><strong>Масштабируемость</strong>: повышает масштабируемость за счет распределения данных по
				нескольким разделам.</li>
			<li><strong>Безопасность</strong>: помогает повысить безопасность системы за счет хранения конфиденциальных
				и неконфиденциальных данных в разных разделах. Это может обеспечить лучшую управляемость и безопасность
				конфиденциальных данных.</li>
			<li><strong>Производительность запросов</strong>: повышает производительность системы. Вместо того, чтобы
				запрашивать всю базу данных, теперь система должна запрашивать только меньший раздел.</li>
			<li><strong>Управление данными</strong>: таблицы и индексы делятся на более мелкие и более управляемые
				единицы.</li>
		</ul>
		<h4>Недостатки</h4>
		<ul>
			<li><strong>Сложность</strong>: Шардинг увеличивает сложность системы в целом.</li>
			<li><strong>Соединения между осколками</strong>: после того, как база данных разделена и распределена по
				нескольким компьютерам, часто невозможно выполнять соединения, охватывающие несколько осколков базы
				данных. Такие соединения не будут эффективными с точки зрения производительности, поскольку данные
				необходимо получать с нескольких серверов.</li>
			<li><strong>Ребалансировка</strong>: если распределение данных неравномерно или на один сегмент приходится
				большая нагрузка, в таких случаях мы должны перебалансировать наши сегменты, чтобы запросы были как
				можно более равномерно распределены между сегментами.</li>
		</ul>
		<h4>Когда использовать шардинг?</h4>
		<p>Вот несколько причин, почему шардинг может быть правильным выбором:</p>
		<ul>
			<li>Использование существующего оборудования вместо высокопроизводительных машин.</li>
			<li>Ведение данных в различных географических регионах.</li>
			<li>Быстро масштабируйте, добавляя больше осколков.</li>
			<li>Лучшая производительность, так как каждая машина находится под меньшей нагрузкой.</li>
			<li>Когда требуется больше одновременных подключений.</li>
		</ul>
		<h3>Консистентное хеширование</h3>
		<p>Давайте сначала поймем проблему, которую мы пытаемся решить.</p>
		<h4>Зачем нам это надо?</h4>
		<p>В традиционных методах распространения на основе хеширования мы используем хеш-функцию для хеширования
			ключей нашего раздела (т. е. идентификатора запроса или IP-адреса). Затем, если мы используем модуль
			по отношению к общему количеству узлов (серверов или баз данных). Это даст нам узел, на который мы хотим
			направить наш запрос.</p>
		<p>$$<br />
			\начать{выравнивать<em>}
				& Hash (key<em>1) \to H</em>1 \bmod N = Node<em>0 \
					& Hash (key</em>2) \to H<em>2 \bmod N = Node</em>1 \<br />
				&amp; Hash (key<em>3) \to H</em>3 \bmod N = Node<em>2 \
					&…\
					& Хэш (key</em>n) \to H<em>n \bmod N = Node</em>{n-1}<br />
				\конец{выравнивание</em>}<br />
			$$</p>
		<p>Где,</p>
		<p><code>key</code>: идентификатор запроса или IP-адрес.</p>
		<p><code>H</code>: Результат хэш-функции.</p>
		<p><code>N</code>: общее количество узлов.</p>
		<p>«Узел»: узел, на который будет направляться запрос.</p>
		<p>Проблема в том, что если мы добавим или удалим узел, это приведет к изменению <code>N</code>, а это
			означает, что наша стратегия сопоставления сломается, поскольку одни и те же запросы теперь будут
			сопоставляться с другим сервером. Как следствие, большинство запросов нужно будет перераспределять,
			что очень неэффективно.</p>
		<p>Мы хотим равномерно распределять запросы между разными узлами, чтобы иметь возможность добавлять или
			удалять узлы с минимальными усилиями. Следовательно, нам нужна схема распределения, не зависящая напрямую
			от количества узлов (или серверов), чтобы при добавлении или удалении узлов количество ключей, которые
			необходимо перемещать, было минимальным.</p>
		<p>Согласованное хеширование решает эту проблему горизонтальной масштабируемости, гарантируя, что каждый раз,
			когда мы увеличиваем или уменьшаем масштаб, нам не нужно переупорядочивать все ключи или трогать все
			серверы.</p>
		<p>Теперь, когда мы поняли проблему, давайте подробно обсудим последовательное хеширование.</p>
		<h4>Как это работает</h4>
		<p>Согласованное хеширование — это схема распределенного хеширования, которая работает независимо от количества
			узлов в распределенной хеш-таблице, назначая им позицию в абстрактном круге или хэш-кольце. Это позволяет
			масштабировать серверы и объекты, не затрагивая систему в целом.</p>
		<p>При использовании согласованного хеширования повторное распределение потребуется только для данных «K/N».</p>
		<p>$$<br />
			Р = К/Н<br />
			$$</p>
		<p>Где,</p>
		<p><code>R</code>: Данные, которые потребуют повторного распространения.</p>
		<p><code>K</code>: Количество ключей раздела.</p>
		<p><code>N</code>: количество узлов.</p>
		<p>Выход хеш-функции — это диапазон, скажем, «0…m-1», который мы можем представить в нашем кольце хеширования.
			Мы хешируем запросы и распределяем их по кольцу в зависимости от того, что было на выходе. Точно так же мы
			также хешируем узел и также распределяем их по тому же кольцу.</p>
		<p>$$<br />
			\начать{выравнивать<em>}
				& Хэш (ключ<em>1) = P</em>1 \<br />
				&amp; Хэш (ключ<em>2) = P</em>2 \<br />
				&amp; Хэш (ключ<em>3) = P</em>3 \<br />
				&amp;…\<br />
				&amp; Хэш (key<em>n) = P</em>{m-1}<br />
				\конец{выравнивание</em>}<br />
			$$</p>
		<p>Где,</p>
		<p><code>key</code>: идентификатор запроса/узла или IP-адрес.</p>
		<p><code>P</code>: Позиция на кольце.</p>
		<p><code>m</code>: общий диапазон хэш-кольца.</p>
		<p>Теперь, когда приходит запрос, мы можем просто направить его к ближайшему узлу по часовой стрелке (можно
			и против часовой стрелки). Это означает, что если новый узел добавляется или удаляется, мы можем
			использовать ближайший узел, и только <em>доля</em> запросов должна быть перенаправлена.</p>
		<p>Теоретически последовательное хеширование должно равномерно распределять нагрузку, однако на практике
			этого не происходит. Обычно распределение нагрузки неравномерно, и один сервер может обрабатывать большую
			часть запросов, становясь <em>горячей точкой</em>, по сути, узким местом для системы. Мы можем исправить
			это, добавив дополнительные узлы, но это может быть дорого.</p>
		<p>Давайте посмотрим, как мы можем решить эти проблемы.</p>
		<h4>Виртуальные узлы</h4>
		<p>Чтобы обеспечить более равномерное распределение нагрузки, мы можем представить идею виртуального узла,
			иногда также называемого VNode.</p>
		<p>Вместо того, чтобы назначать узлу одну позицию, диапазон хэшей делится на несколько меньших диапазонов,
			и каждому физическому узлу назначается несколько таких меньших диапазонов. Каждый из этих поддиапазонов
			считается VNode. Следовательно, виртуальные узлы — это, по сути, существующие физические узлы, многократно
			отображаемые в хеш-кольце, чтобы свести к минимуму изменения в назначенном узлу диапазоне.</p>
		<p>Для этого мы можем использовать k хэш-функций.</p>
		<p>$$<br />
			\начать{выравнивать<em>}
				& Хэш<em>1(ключ</em>1) = P<em>1 \
					& Хэш</em>2(ключ<em>2) = P</em>2 \<br />
				&amp; Хэш<em>3(ключ</em>3) = P<em>3 \
					&. . . \
					& Hash</em>k (key<em>n) = P</em>{m-1}<br />
				\конец{выравнивание</em>}<br />
			$$</p>
		<p>Где,</p>
		<p><code>key</code>: идентификатор запроса/узла или IP-адрес.</p>
		<p><code>k</code>: количество хеш-функций.</p>
		<p><code>P</code>: Позиция на кольце.</p>
		<p><code>m</code>: общий диапазон хэш-кольца.</p>
		<p>Поскольку виртуальные узлы помогают более равномерно распределять нагрузку по физическим узлам в кластере,
			разделяя диапазоны хэшей на более мелкие поддиапазоны, это ускоряет процесс повторной балансировки после
			добавления или удаления узлов. Это также помогает нам снизить вероятность горячих точек.</p>
		<h4>Репликация данных</h4>
		<p>Чтобы обеспечить высокую доступность и надежность, согласованное хеширование реплицирует каждый элемент
			данных на множестве N узлов в системе, где значение N эквивалентно <em>коэффициенту репликации</em>.</p>
		<p>Коэффициент репликации — это количество узлов, которые получат копию одних и тех же данных. В окончательно
			непротиворечивых системах это делается асинхронно.</p>
		<h4>Преимущества</h4>
		<p>Давайте рассмотрим некоторые преимущества последовательного хеширования:</p>
		<ul>
			<li>Делает быстрое масштабирование вверх и вниз более предсказуемым.</li>
			<li>Облегчает разделение и репликацию между узлами.</li>
			<li>Обеспечивает масштабируемость и доступность.</li>
			<li>Уменьшает горячие точки.</li>
		</ul>
		<h4>Недостатки</h4>
		<p>Ниже приведены некоторые недостатки последовательного хеширования:</p>
		<ul>
			<li>Увеличивает сложность.</li>
			<li>Каскадные сбои.</li>
			<li>Распределение нагрузки по-прежнему может быть неравномерным.</li>
			<li>Управление ключами может быть дорогостоящим, когда узлы временно выходят из строя.</li>
		</ul>
		<h4>Примеры</h4>
		<p>Давайте рассмотрим несколько примеров, где используется последовательное хеширование:</p>
		<ul>
			<li>Разделение данных в <a href="https://cassandra.apache.org">Apache Cassandra</a>.</li>
			<li>Распределение нагрузки между несколькими хостами хранилища в <a href="https://aws.amazon.com/dynamodb">
				Amazon DynamoDB</a>.</li>
		</ul>
		<h3>Федерация базы данных</h3>
		<p>Федерация (или функциональное разделение) разделяет базы данных по функциям. В архитектуре федерации
			несколько отдельных физических баз данных представляются конечным пользователям как одна логическая
			база данных.</p>
		<p>Все компоненты федерации связаны между собой одной или несколькими федеральными схемами, которые выражают
			общность данных по всей федерации. Эти федеративные схемы используются для указания информации, которая
			может совместно использоваться компонентами федерации, и для обеспечения общей основы для связи между
			ними.</p>
		<p>Федерация также обеспечивает связное, унифицированное представление данных, полученных из нескольких
			источников. Источники данных для федеративных систем могут включать базы данных и различные другие
			формы структурированных и неструктурированных данных.</p>
		<h4>Характеристики</h4>
		<p>Давайте рассмотрим некоторые ключевые характеристики федеративной базы данных:</p>
		<ul>
			<li><strong>Прозрачность</strong>: объединенная база данных маскирует различия между пользователями и
				реализациями базовых источников данных. Поэтому пользователям не нужно знать, где хранятся данные.</li>
			<li><strong>Неоднородность</strong>: источники данных могут различаться по многим параметрам. Система
				федеративных баз данных может обрабатывать различное оборудование, сетевые протоколы, модели данных
				и т. д.</li>
			<li><strong>Расширяемость</strong>: для удовлетворения меняющихся потребностей бизнеса могут потребоваться
				новые источники. Хорошая федеративная система баз данных должна позволять легко добавлять новые
				источники.</li>
			<li><strong>Автономия</strong>: объединенная база данных не изменяет существующие источники данных,
				интерфейсы должны оставаться прежними.</li>
			<li><strong>Интеграция данных</strong>: объединенная база данных может интегрировать данные из различных
				протоколов, систем управления базами данных и т. д.</li>
		</ul>
		<h4>Преимущества</h4>
		<p>Вот некоторые преимущества федеративных баз данных:</p>
		<ul>
			<li>Гибкий обмен данными.</li>
			<li>Автономность среди компонентов базы данных.</li>
			<li>Единый доступ к разнородным данным.</li>
			<li>Нет тесной связи приложений с устаревшими базами данных.</li>
		</ul>
		<h4>Недостатки</h4>
		<p>Ниже приведены некоторые недостатки федеративных баз данных:</p>
		<ul>
			<li>Добавляет больше оборудования и дополнительную сложность.</li>
			<li>Объединение данных из двух баз данных является сложным.</li>
			<li>Зависимость от автономных источников данных.</li>
			<li>Производительность запросов и масштабируемость.</li>
		</ul>
	</div>
</section>

